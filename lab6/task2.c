#include<stdio.h>  // Вариант 18
int main() {
    int sim = 0, perf = 0, perf_ind = 0, sim_ind = 0;
    int X[10]={4,6,8,1,9,15,67,28,32,19}; //совершенные: 6 28 // простые: 67 19  // меняем местами 6 и 19
    // 6-16 строки - поиск последнего простого числа
     for (int i = 0; i<10; i++ ){ //перебор индексов массива
        int simple = 0, sum_del = 0;
        for (int j=2; j<X[i]; j++){  // перебор потенциальных делителей числа 
            if (X[i]%j==0){
                simple = 1; // если находится делитель числа, то 1
            }
        }
        if ((simple==0) && (X[i]>1)) { // если у числа нет делителей и оно больше 1 (простое), то сохраняем его в sim и его индекс в массиве в sim_ind
            sim = X[i]; 
            sim_ind =  i;
        } 

    // строки 19-27 - поиск первого совершенного числа, если оно еще не найдено
        if (perf == 0) {
            for (int j=2; j<X[i]; j++){  // перебор потенциальных делителей числа 
                if (X[i]%j==0)
                    sum_del += j;} // находим сумму всех делителей
            if (((sum_del+1)==X[i]) && (X[i]>1)) { // если сумма+1 = числу (совершенное), то то сохраняем его в perf и его индекс в массиве в perf_ind
                perf = X[i]; 
                perf_ind = i;
                }
        }
    }
    //проверки на наличие простых и совершенных чисел в массиве
    if (sim==0 && perf==0){
        printf("нет простых и совершенных чисел в массиве\n");
    } else if (sim==0){
        printf("нет простых чисел в массиве\n");
    } else if (perf==0){
        printf("нет совершенных чисел в массиве\n");
    } else {
        X[sim_ind] = perf; // меняем местами первое совершенное и последнее простое
        X[perf_ind] = sim;
        //printf("массив после перестановки чисел: ");
        //for (int i = 0; i<10; i++ ){printf("%d ", X[i]);}
        //printf("\n");
    }
    for (int i = 0; i<10; i++ ){ //вывод элементов массива без четных значений 
         if (X[i]%2!=0) printf();

        }
     

}
